use dbus::arg;
use dbus::blocking;

mod keyboard;

const INTERFACE: &'static str = "nl.icewind.shortcutd";

pub trait NlIcewindShortcutd {
    fn register(&self, shortcut: &str) -> Result<String, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> NlIcewindShortcutd
    for blocking::Proxy<'a, C>
{
    fn register(&self, shortcut: &str) -> Result<String, dbus::Error> {
        self.method_call(INTERFACE, "Register", (shortcut,))
            .and_then(|r: (String,)| Ok(r.0))
    }
}

#[derive(Debug)]
pub struct NlIcewindShortcutdTriggered {}

impl arg::AppendAll for NlIcewindShortcutdTriggered {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for NlIcewindShortcutdTriggered {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(NlIcewindShortcutdTriggered {})
    }
}

impl dbus::message::SignalArgs for NlIcewindShortcutdTriggered {
    const NAME: &'static str = "Triggered";
    const INTERFACE: &'static str = INTERFACE;
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> OrgFreedesktopDBusIntrospectable
    for blocking::Proxy<'a, C>
{
    fn introspect(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
            .and_then(|r: (String,)| Ok(r.0))
    }
}

// Autogenerated code ends here.

pub use crate::keyboard::Shortcut;
use dbus::blocking::Connection;
use dbus::Message;
use std::time::Duration;

pub struct ShortcutClient {
    connection: Connection,
}

impl ShortcutClient {
    pub fn new() -> Result<Self, dbus::Error> {
        Ok(ShortcutClient {
            connection: Connection::new_system()?,
        })
    }

    pub fn register(
        &mut self,
        shortcut: Shortcut,
        handler: impl Fn(Shortcut) + Send + 'static,
    ) -> Result<(), dbus::Error> {
        let path = self
            .connection
            .with_proxy(INTERFACE, "/register", Duration::from_millis(5000))
            .register(&format!("{}", shortcut))?;

        let proxy = self
            .connection
            .with_proxy(INTERFACE, &path, Duration::from_millis(5000));

        // Let's start listening to signals.
        let _id = proxy.match_signal(
            move |_: NlIcewindShortcutdTriggered, _: &Connection, _: &Message| {
                handler(shortcut.clone());
                true
            },
        );

        Ok(())
    }

    pub fn process(&mut self, timeout: Duration) -> Result<(), dbus::Error> {
        self.connection.process(timeout)?;
        Ok(())
    }
}
